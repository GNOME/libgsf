/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#include <Python.h>

#include "pygobject.h"
#include <orbit-python.h>
#include <gsf/gsf-input.h>
#include <gsf/gsf-input-stdio.h>
#include <gsf/gsf-input-memory.h>
#include <gsf/gsf-input-textline.h>
#include <gsf/gsf-input-gzip.h>
#include <gsf/gsf-input-bonobo.h>
#include <gsf/gsf-input-gnomevfs.h>
#include <gsf/gsf-infile.h>
#include <gsf/gsf-infile-msole.h>
#include <gsf/gsf-infile-msvba.h>
#include <gsf/gsf-infile-zip.h>
#include <gsf/gsf-io-context.h>
#include <gsf/gsf-output.h>
#include <gsf/gsf-outfile.h>
#include <gsf/gsf-outfile-msole.h>
#include <gsf/gsf-output-bonobo.h>
#include <gsf/gsf-output-gnomevfs.h>
#include <gsf/gsf-output-stdio.h>

#define GSF_TYPE_INPUT GSF_INPUT_TYPE
#define GSF_TYPE_INPUT_STDIO GSF_INPUT_STDIO_TYPE
#define GSF_TYPE_INPUT_MEMORY GSF_INPUT_MEMORY_TYPE
#define GSF_TYPE_INPUT_TEXTLINE GSF_INPUT_TEXTLINE_TYPE
#define GSF_TYPE_INPUT_GZIP GSF_INPUT_GZIP_TYPE
#define GSF_TYPE_INPUT_BONOBO GSF_INPUT_BONOBO_TYPE
#define GSF_TYPE_INPUT_GNOME_VFS GSF_INPUT_GNOMEVFS_TYPE
#define GSF_TYPE_INFILE GSF_INFILE_TYPE
#define GSF_TYPE_INFILE_ZIP GSF_INFILE_ZIP_TYPE
#define GSF_TYPE_INFILE_MSVBA GSF_INFILE_MSVBA_TYPE
#define GSF_TYPE_INFILE_MS_OLE GSF_INFILE_MSOLE_TYPE
#define GSF_TYPE_IO_CONTEXT GSF_IO_CONTEXT_TYPE
#define GSF_TYPE_META_DATA_BAG GSF_METADATA_BAG_TYPE
#define GSF_TYPE_OUTPUT GSF_OUTPUT_TYPE
#define GSF_TYPE_OUTFILE GSF_OUTFILE_TYPE
#define GSF_TYPE_OUTFILE_MS_OLE GSF_OUTFILE_MSOLE_TYPE
#define GSF_TYPE_OUTPUT_BONOBO GSF_OUTPUT_BONOBO_TYPE
#define GSF_TYPE_OUTPUT_GNOME_VFS GSF_OUTPUT_GNOMEVFS_TYPE
#define GSF_TYPE_OUTPUT_MEMORY GSF_OUTPUT_MEMORY_TYPE
#define GSF_TYPE_OUTPUT_STDIO GSF_OUTPUT_STDIO_TYPE
%%
modulename gsf
%%
import gobject.GObject as PyGObject_Type
%%
ignore-glob
 _*
 gsf_input_set_*
 *_get_type
 gsf_metadata_bag_*
 gsf_output_memory_*
 gsf_*_error
%%
override gsf_input_size noargs
static PyObject *
_wrap_gsf_input_size(PyGObject *self)
{
    long ret;
    gsf_off_t size = gsf_input_size(GSF_INPUT(self->obj));

    ret = size;
    if (ret != size) {		/* Check for overflow */
	PyErr_SetString(PyExc_OverflowError, "Size is too large");
    }
    return PyInt_FromLong(ret);
}
%%
override gsf_input_read kwargs
static PyObject *
_wrap_gsf_input_read(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char *) "num_bytes", 
			      (char *) "optional_buffer", NULL };
    size_t num_bytes;
    guint8 *optional_buffer = NULL;
    guint8 const *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i|z:GsfInput.read",
				     kwlist, &num_bytes, &optional_buffer))
        return NULL;
    ret = gsf_input_read(GSF_INPUT(self->obj), num_bytes, optional_buffer);
    if (ret)
        return PyString_FromStringAndSize(ret, (int) num_bytes);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gsf_input_seek kwargs
static PyObject *
_wrap_gsf_input_seek(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char *) "offset", (char *) "whence", NULL };
    long loffset;
    gsf_off_t offset;
    GsfSeekType whence;
    gboolean ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "li:GsfInput.seek",
				     kwlist, &loffset, &whence))
        return NULL;
    offset = loffset;
    ret = gsf_input_seek(GSF_INPUT(self->obj), offset, whence);
    return PyInt_FromLong(ret);
}
%%
override gsf_input_remaining noargs
static PyObject *
_wrap_gsf_input_remaining(PyGObject *self)
{
    long ret;
    gsf_off_t remain = gsf_input_remaining(GSF_INPUT(self->obj));

    ret = remain;
    if (ret != remain) {		/* Check for overflow */
	PyErr_SetString(PyExc_OverflowError, "Size is too large");
    }
    return PyInt_FromLong(ret);
}
%%
override gsf_input_tell noargs
static PyObject *
_wrap_gsf_input_tell(PyGObject *self)
{
    long ret;
    gsf_off_t pos = gsf_input_tell(GSF_INPUT(self->obj));
    ret = pos;
    if (ret != pos) {		/* Check for overflow */
	PyErr_SetString(PyExc_OverflowError, "Position is too large");
    }
    return PyInt_FromLong(ret);
}
%%
override gsf_input_memory_new kwargs
static int
_wrap_gsf_input_memory_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {
	(char *) "buf", (char *) "needs_free", NULL };
    guint8 *buf;
    size_t length;
    gboolean needs_free;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     (char *) "s#i:GsfInputMemory.__init__",
				     kwlist, &buf, &length, &needs_free))
        return -1;
    self->obj = (GObject *)gsf_input_memory_new(buf, (gsf_off_t) length,
						needs_free);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GsfInputMemory object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gsf_input_textline_ascii_gets noargs
static PyObject *
_wrap_gsf_input_textline_ascii_gets(PyGObject *self)
{
    const unsigned char *ret;

    ret = gsf_input_textline_ascii_gets(GSF_INPUT_TEXTLINE(self->obj));
    if (ret)
        return PyString_FromString(ret);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gsf_input_bonobo_new kwargs
static int
_wrap_gsf_input_bonobo_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char *) "stream", NULL };
    PyObject *stream;
    GError *err = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     (char *) "O:GsfInputBonobo.__init__",
				     kwlist, &stream))
        return -1;
    if (!PyORBit_Object_Check(stream)) {
        PyErr_SetString(PyExc_TypeError, "stream must be a CORBA.Object");
        return -1;
    }
    self->obj = (GObject *)gsf_input_bonobo_new((CORBA_Object)PyORBit_Object_Get(stream), &err);
    if (pyg_error_check(&err))
        return -1;

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GsfInputBonobo object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gsf_output_size noargs
static PyObject *
_wrap_gsf_output_size(PyGObject *self)
{
    long ret;
    gsf_off_t size = gsf_output_size(GSF_OUTPUT(self->obj));

    ret = size;
    if (ret != size) {		/* Check for overflow */
	PyErr_SetString(PyExc_OverflowError, "Size is too large");
    }
    return PyInt_FromLong(ret);
}
%%
override gsf_output_tell noargs
static PyObject *
_wrap_gsf_output_tell(PyGObject *self)
{
    long ret;
    gsf_off_t pos = gsf_output_tell(GSF_OUTPUT(self->obj));
    ret = pos;
    if (ret != pos) {		/* Check for overflow */
	PyErr_SetString(PyExc_OverflowError, "Position is too large");
    }
    return PyInt_FromLong(ret);
}
%%
override gsf_output_seek kwargs
static PyObject *
_wrap_gsf_output_seek(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char *) "offset", (char *) "whence", NULL };
    long loffset;
    gsf_off_t offset;
    GsfSeekType whence;
    gboolean ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     (char *) "li:GsfOutput.seek",
				     kwlist, &loffset, &whence))
        return NULL;
    offset = loffset;
    ret = gsf_output_seek(GSF_OUTPUT(self->obj), offset, whence);
    return PyInt_FromLong(ret);
}
%%
override gsf_output_write kwargs
static PyObject *
_wrap_gsf_output_write(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { (char *) "num_bytes", (char *) "data", NULL };
    size_t num_bytes, ret;
    char *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     (char *) "is:GsfOutput.write",
				     kwlist, &num_bytes, &data))
        return NULL;
    ret = gsf_output_write(GSF_OUTPUT(self->obj), num_bytes, data);
    return PyInt_FromLong((long) ret);
}
%%
override gsf_output_bonobo_new kwargs
static int
_wrap_gsf_output_bonobo_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "stream", NULL };
    PyObject *stream;
    GError *err = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GsfOutputBonobo.__init__", kwlist, &stream))
        return -1;
    if (!PyORBit_Object_Check(stream)) {
        PyErr_SetString(PyExc_TypeError, "stream must be a CORBA.Object");
        return -1;
    }
    self->obj = (GObject *)gsf_output_bonobo_new((CORBA_Object)PyORBit_Object_Get(stream), &err);
    if (pyg_error_check(&err))
        return -1;

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GsfOutputBonobo object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
